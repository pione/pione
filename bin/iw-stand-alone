#!/usr/bin/env ruby
# -*- ruby -*-

require 'optparse'
require 'innocent-white/common'
require 'innocent-white/agent/input-generator'
require 'innocent-white/agent/task-worker'
require 'innocent-white/agent/rule-provider'
require 'innocent-white/agent/logger'

include InnocentWhite

Thread.abort_on_exception = true

#
# parse options
#

$input_dir = "input"
$output_dir = "output"
$log_path = "log.txt"
$stream = false

OPTS = {}
OPTS[:resource] = 1

option_parser = OptionParser.new do |opt|
  opt.on('-i dir', '--input-dir=dir') {|dir| $input_dir = dir }
  opt.on('-o dir', '--output-dir=dir') {|dir| $output_dir = dir}
  opt.on('-l log', '--log=file') {|path| $log_path = path }
  opt.on('-s', '--stream') { $stream = true }
  opt.on('-r n''--resource=n') {|n|
    OPTS[:resource] = n.to_i
    unless OPTS[:resource] > 0
      puts "invalid resource size: #{OPTS[:resource]}"
      exit
    end
  }
  opt.on('-d', '--debug') {|name| InnocentWhite.debug_mode = true }
  opt.on('--color=true or false') {|str|
    bool = nil
    bool = true if str == "true"
    bool = false if str == "false"
    if bool.nil?
      puts "invalid color option: %s" % bool
      exit
    end
    Terminal.color_mode = bool
  }
end

begin
  option_parser.parse!(ARGV)
rescue OptionParser::InvalidOption => e
  e.args.each {|arg| puts "unknown option: #{arg}" }
  exit
end

if ARGF.filename == "-"
  puts "no process definition document"
  exit
end

#
# start process
#

# get script dirname
$dir = File.dirname(File.expand_path(__FILE__))

# base uri
uri = "local:#{Dir.mktmpdir('innocent-white-')}/"

# make drb server and it's connection
$tuple_space_server = TupleSpaceServer.new(task_worker_resource: 1, base_uri: uri)
provider = InnocentWhite::TupleSpaceProvider.instance
provider.add($tuple_space_server)
# $remote_drb_server = DRb::DRbServer.new(nil, $tuple_space_server)
# $remote_server = DRbObject.new(nil, $remote_drb_server.uri)

# make logger
Agent[:logger].start($tuple_space_server, File.open($log_path, "w+"))

# read process document
$doc = Document.parse(ARGF.read)

# start rule provider
rule_loader = Agent[:rule_provider].start($tuple_space_server)
rule_loader.read_document($doc)
rule_loader.wait_till(:request_waiting)
$tuple_space_server.write(Tuple[:process_info].new('standalone', 'Standalone'))

# start input generators
generator_method = $stream ? :start_by_stream : :start_by_dir
gen = Agent[:input_generator].send(generator_method, $tuple_space_server, $input_dir)
sleep 0.1 while not(gen.counter > 0)

# add workers
OPTS[:resource].times do
  Agent[:task_worker].start($tuple_space_server)
end

# execute
root = Rule::RootRule.new(RuleExpr.new('Main'))

class CommandExecuter
  def terminate
    begin
      Thread.abort_on_exception = false
      puts ">>> system terminate"
      $tuple_space_server.terminate
      $thread.terminate
    rescue Object => e
      # do nothing
    end
  end
end

Agent[:command_listener].start($tuple_space_server, CommandExecuter.new)

#
# start rule handling
#
$thread = Thread.start do
  InnocentWhite.debug_mode do
    while true do
      handler = root.make_handler($tuple_space_server)
      outputs = handler.execute
      Dir.mkdir($output_dir) unless File.exist?($output_dir)
      outputs.first.each do |output|
        path = File.join($output_dir, output.name)
        File.open(path, "w+"){|out| out.write(Resource[output.uri].read)}
      end

      tuples = []
      bag = $tuple_space_server.tuple_space.instance_variable_get("@bag")
      bag.instance_variable_get("@hash").values.each do |bin|
        tuples += bin.instance_variable_get("@bin")
      end

      break unless $stream
      sleep 5
    end
  end
end
$thread.join
