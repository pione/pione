#!/usr/bin/env ruby
# -*- ruby -*-

require 'optparse'
require 'pione'

include Pione
Thread.abort_on_exception = true

#
# parse options
#

Option = Struct.new(
  :input_dir, :output_dir, :log_path, :stream, :params, :base_uri
)
option = Option.new(
  nil, "output", "log.txt", false, Parameters.empty
)

OPTS = {}
OPTS[:resource] = 1

parser = OptionParser.new do |opt|
  opt.on('-i dir', '--input-dir=dir') {|dir| option.input_dir = dir }
  opt.on('-o dir', '--output-dir=dir') {|dir| option.output_dir = dir}
  opt.on('-b uri', '--base-uri=uri') {|uri|
    base_uri = ::URI.parse(uri)
    if base_uri.scheme == "local"
      FileUtils.makedirs(base_uri.path)
      base_uri = base_uri.absolute
    end
    option.base_uri = base_uri.to_s
  }
  opt.on('-l path', '--log=path') {|path| option.log_path = path }
  opt.on('-s', '--stream') { option.stream = true }
  opt.on('-r n', '--resource=n') {|n|
    OPTS[:resource] = n.to_i
    unless OPTS[:resource] > 0
      puts "invalid resource size: #{OPTS[:resource]}"
      exit
    end
  }
  opt.on('-d', '--debug') {|name| Pione.debug_mode = true }
  opt.on('--color=true or false') {|str|
    bool = nil
    bool = true if str == "true"
    bool = false if str == "false"
    if bool.nil?
      puts "invalid color option: %s" % bool
      exit
    end
    Terminal.color_mode = bool
  }
  opt.on('--params="{Var:1,...}"') {|str|
    option.params = Transformer.new.apply(Parser.new.parameters.parse(str))
  }
end

begin
  parser.parse!(ARGV)
rescue OptionParser::InvalidOption => e
  e.args.each {|arg| $stderr.puts "Unknown option: #{arg}" }
  abort
end

# process definition document is not found.
if ARGF.filename == "-"
  puts "There are no process definition documents."
  abort
end

#
# start process
#

# get script dirname
$dir = File.dirname(File.expand_path(__FILE__))

# base uri
unless option.base_uri
  option.base_uri = "local:./output/"
end

# make drb server and it's connection
$tuple_space_server = TupleSpaceServer.new(
  task_worker_resource: 1,
  base_uri: option.base_uri
)
provider = Pione::TupleSpaceProvider.instance
provider.add($tuple_space_server)
# $remote_drb_server = DRb::DRbServer.new(nil, $tuple_space_server)
# $remote_server = DRbObject.new(nil, $remote_drb_server.uri)

# make logger
Agent[:logger].start($tuple_space_server, File.open(option.log_path, "w+"))

# read process document
begin
  $doc = Document.parse(ARGF.read)
rescue Pione::Parser::ParserError => e
  abort("Pione syntax error: " + e.message)
rescue Pione::Model::PioneModelTypeError, Pione::Model::VariableBindingError => e
  abort("Pione model error: " + e.message)
end

# start rule provider
rule_loader = Agent[:rule_provider].start($tuple_space_server)
rule_loader.read_document($doc)
rule_loader.wait_till(:request_waiting)

$tuple_space_server.write(Tuple[:process_info].new('standalone', 'Standalone'))

# start input generators
generator_method = option.stream ? :start_by_stream : :start_by_dir
gen = Agent[:input_generator].send(
  generator_method, $tuple_space_server, option.input_dir
)
sleep 0.1 while not(gen.counter > 0)

# add workers
OPTS[:resource].times do
  Agent[:task_worker].start($tuple_space_server)
end

class CommandExecuter
  def terminate
    begin
      Thread.abort_on_exception = false
      puts ">>> system terminate"
      $tuple_space_server.terminate
      $thread.terminate
    rescue Object => e
      # do nothing
    end
  end
end

Agent[:command_listener].start($tuple_space_server, CommandExecuter.new)

#
# start rule handling
#
$thread = Thread.start do
  while true do
    if handler = $doc.root_rule(option.params).make_handler($tuple_space_server)
      outputs = handler.handle
      Dir.mkdir(option.output_dir) unless File.exist?(option.output_dir)
      outputs.first.each do |output|
        path = File.join(option.output_dir, output.name)
        File.open(path, "w+"){|out| out.write(Resource[output.uri].read)}
      end
    else
      user_message "no inputs"
    end

    break unless option.stream
    sleep 5
    user_message "check new inputs"
  end
end
$thread.join
